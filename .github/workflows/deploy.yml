name: Deploy to Server

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.2.0
        continue-on-error: false
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 30m
          script_stop: true
          debug: true
          envs: GITHUB_REPO=${{ github.repository }},SERVER_HOST=${{ secrets.SERVER_HOST }}
          script: |
            # 遇到任何命令错误(非逻辑判断)则退出
            set -e
            
            PROJECT_DIR="/home/ubuntu/telegram-ai-system"
            
            echo "🚀 开始部署..."
            echo "时间: $(date)"
            echo "系统资源:"
            free -h || true
            echo ""
            
            # 0. 启用 Swap（如果未启用）
            echo "检查并启用 Swap..."
            sudo swapon /swapfile 2>/dev/null || echo "Swap 已启用或文件不存在"
            free -h || true
            echo ""
            
            # 1. 预检：如果目录存在但不是 git 仓库，先清理
            if [ -d "$PROJECT_DIR" ] && [ ! -d "$PROJECT_DIR/.git" ]; then
                echo "⚠️  发现无效项目目录（缺少 .git），正在清理..."
                sudo rm -rf "$PROJECT_DIR"
                echo "✅ 无效目录已清理"
            fi
            
            # 2. 检查并创建项目目录（如果不存在）
            if [ ! -d "$PROJECT_DIR" ]; then
                echo "项目目录不存在，正在创建并克隆代码..."
                sudo mkdir -p "$PROJECT_DIR"
                sudo chown -R ubuntu:ubuntu "$PROJECT_DIR"
                # 克隆代码
                sudo -u ubuntu git clone https://github.com/victor2025PH/liaotianai1201.git "$PROJECT_DIR"
                echo "✅ 代码克隆完成"
            fi
            
            # 3. 确保目录权限正确
            sudo chown -R ubuntu:ubuntu "$PROJECT_DIR" || true
            sudo chmod 755 "$PROJECT_DIR" || true
            
            # 4. 进入目录并更新代码
            cd "$PROJECT_DIR" || {
                echo "❌ 无法进入项目目录，检查权限..."
                ls -la "$PROJECT_DIR" || true
                exit 1
            }
            
            # 验证是 git 仓库
            if [ ! -d ".git" ]; then
                echo "❌ 错误：目录不是 git 仓库，这不应该发生"
                exit 1
            fi
            
            echo "📥 更新代码..."
            sudo -u ubuntu git fetch origin main
            sudo -u ubuntu git reset --hard origin/main
            echo "✅ 代码更新完成"
            
            # 2. 确保权限正确（再次确认）
            sudo chown -R ubuntu:ubuntu "$PROJECT_DIR" || true
            
            # 3. 构建前端
            echo "📦 构建前端..."
            cd saas-demo
            
            # 1. 清理锁文件（不停止服务，减少中断时间）
            rm -f .next/lock
            
            # 2. 检查内存和 Swap
            echo "检查系统资源..."
            free -h || true
            echo ""
            echo "启用 Swap（如果未启用）..."
            sudo swapon /swapfile 2>/dev/null || echo "Swap 已启用或文件不存在"
            free -h || true
            echo ""
            
            # 3. 安装与构建（在服务运行的情况下构建）
            # 使用 NODE_OPTIONS 限制 Node.js 内存使用（512MB，更保守）
            export NODE_OPTIONS="--max-old-space-size=512"
            npm install --prefer-offline --no-audit
            
            # 构建时也限制内存
            NODE_OPTIONS="--max-old-space-size=512" npm run build
            
            # 处理静态资源 (Next.js standalone 模式要求)
            echo "📂 处理静态资源..."
            
            # 查找 standalone 目录的实际位置（可能是 .next/standalone 或 .next/standalone/saas-demo）
            STANDALONE_DIR=""
            if [ -d ".next/standalone" ]; then
                # 检查是否有嵌套的项目目录
                if [ -d ".next/standalone/saas-demo" ]; then
                    STANDALONE_DIR=".next/standalone/saas-demo"
                elif [ -f ".next/standalone/server.js" ]; then
                    STANDALONE_DIR=".next/standalone"
                else
                    # 查找包含 server.js 的目录
                    STANDALONE_DIR=$(find .next/standalone -type f -name "server.js" 2>/dev/null | head -1 | xargs dirname 2>/dev/null || echo ".next/standalone")
                fi
            fi
            
            if [ -z "$STANDALONE_DIR" ] || [ ! -d "$STANDALONE_DIR" ]; then
                echo "❌ standalone 目录不存在，构建可能失败"
                exit 1
            fi
            
            echo "✅ 找到 standalone 目录: $STANDALONE_DIR"
            
            # 确保 .next 目录存在
            mkdir -p "$STANDALONE_DIR/.next/static"
            mkdir -p "$STANDALONE_DIR/.next/server"
            
            # 复制静态资源
            if [ -d ".next/static" ]; then
                cp -r .next/static/* "$STANDALONE_DIR/.next/static/" 2>/dev/null || true
                echo "✅ 静态资源已复制"
            else
                echo "⚠️  .next/static 目录不存在"
            fi
            
            # 复制 public 目录（如果不存在）
            if [ -d "public" ] && [ ! -d "$STANDALONE_DIR/public" ]; then
                cp -r public "$STANDALONE_DIR/" 2>/dev/null || true
                echo "✅ public 目录已复制"
            fi
            
            # 复制 BUILD_ID
            if [ -f ".next/BUILD_ID" ]; then
                mkdir -p "$STANDALONE_DIR/.next"
                cp .next/BUILD_ID "$STANDALONE_DIR/.next/BUILD_ID" 2>/dev/null || true
            fi
            
            # 复制 JSON 配置文件
            for json_file in .next/*.json; do
                if [ -f "$json_file" ]; then
                    mkdir -p "$STANDALONE_DIR/.next"
                    cp "$json_file" "$STANDALONE_DIR/.next/" 2>/dev/null || true
                fi
            done
            
            # 复制 server 目录（如果存在）
            if [ -d ".next/server" ]; then
                cp -r .next/server/* "$STANDALONE_DIR/.next/server/" 2>/dev/null || true
                echo "✅ server 目录已复制"
            fi
            
            echo "✅ 静态资源处理完成"
            cd ..
            
            # 4. 后端依赖
            echo "🐍 安装后端依赖..."
            
            # 1. 强制安装系统级依赖（不要检查，直接装，确保环境存在）
            echo "🔧 正在安装系统依赖..."
            # 使用非交互模式防止卡住
            sudo DEBIAN_FRONTEND=noninteractive apt-get update -q
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python3 python3-venv python3-pip psmisc
            
            cd admin-backend || exit 1
            
            # 2. 重建虚拟环境（先删后建，防止环境损坏）
            echo "📦 重建虚拟环境..."
            rm -rf venv
            python3 -m venv venv
            
            # 3. 激活环境（使用点号 . 代替 source，兼容所有 Shell）
            echo "🔌 激活虚拟环境..."
            if [ -f "venv/bin/activate" ]; then
                . venv/bin/activate
            else
                echo "❌ 严重错误：虚拟环境创建失败"
                exit 1
            fi
            
            # 4. 安装依赖
            echo "📥 安装 pip 依赖..."
            pip install --upgrade pip --quiet
            pip install -r requirements.txt --quiet
            
            echo "✅ 后端依赖安装完成"
            cd ..
            
            # 5. 重启服务（使用 PM2）
            echo "🔄 重启服务..."
            
            # 检查前端构建产物是否存在（Next.js standalone 模式要求）
            echo "🔍 检查前端构建产物..."
            
            # 查找 standalone/server.js 的实际路径（可能是 .next/standalone/server.js 或 .next/standalone/xxx/server.js）
            STANDALONE_SERVER=""
            if [ -f "saas-demo/.next/standalone/server.js" ]; then
                STANDALONE_SERVER="saas-demo/.next/standalone/server.js"
            else
                # 尝试查找嵌套路径（如 .next/standalone/saas-demo/server.js）
                STANDALONE_SERVER=$(find saas-demo/.next/standalone -name "server.js" 2>/dev/null | head -1 || echo "")
            fi
            
            if [ -z "$STANDALONE_SERVER" ] || [ ! -f "$STANDALONE_SERVER" ]; then
                echo "❌ 错误：前端 standalone 构建产物不存在"
                echo "   请检查前端构建是否成功完成"
                echo "   当前目录: $(pwd)"
                echo "   saas-demo/.next 目录内容:"
                ls -la saas-demo/.next/ 2>/dev/null | head -20 || echo "   .next 目录不存在"
                if [ -d "saas-demo/.next/standalone" ]; then
                    echo "   standalone 目录内容:"
                    find saas-demo/.next/standalone -name "server.js" 2>/dev/null || echo "   未找到 server.js"
                fi
                exit 1
            fi
            echo "✅ 前端构建产物检查通过: $STANDALONE_SERVER"
            
            # 确保日志目录存在
            mkdir -p logs || true
            sudo chown -R ubuntu:ubuntu logs || true
            
            # 切换到 ubuntu 用户执行 PM2 命令
            # 注意：PM2 需要以运行服务的用户身份执行
            
            # 确保安装了 fuser（再次检查，防止前面安装失败）
            if ! command -v fuser &> /dev/null; then
                echo "🔧 安装 psmisc (fuser)..."
                sudo DEBIAN_FRONTEND=noninteractive apt-get install -y psmisc
            fi
            
            # 1. 停止所有 PM2 进程
            echo "🛑 停止 PM2 服务..."
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 stop all || true"
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 delete all || true"

            # 2. 智能查杀逻辑（查找并处理守护进程）
            # 安装必要工具
            if ! command -v netstat &> /dev/null; then
                sudo DEBIAN_FRONTEND=noninteractive apt-get install -y net-tools
            fi

            echo "🔍 深度诊断端口 3000..."

            # 查找占用端口的进程及其父进程
            PID=$(sudo lsof -t -i:3000 2>/dev/null | head -1 || echo "")
            if [ -n "$PID" ]; then
                echo "⚠️  发现端口 3000 被 PID $PID 占用"

                # 获取父进程 ID
                PPID=$(ps -o ppid= -p $PID 2>/dev/null | tr -d ' ' || echo "")
                if [ -n "$PPID" ]; then
                    echo "   该进程由父进程 PID $PPID 管理"
                    # 打印父进程详情
                    ps -f -p $PPID 2>/dev/null || echo "   无法获取父进程详情"

                    # 策略 A: 如果父进程是 Systemd (PID 1)，说明是系统服务
                    if [ "$PPID" -eq "1" ]; then
                        echo "🚨 发现 Systemd 服务在运行！正在尝试定位并停止..."
                        # 尝试通过 systemctl status 查找服务名
                        SERVICE_NAME=$(sudo systemctl status $PID 2>/dev/null | grep -o "Loaded: loaded (/.*" | awk '{print $3}' | xargs basename 2>/dev/null | cut -d';' -f1 || echo "")
                        if [ -n "$SERVICE_NAME" ] && [ "$SERVICE_NAME" != "" ]; then
                            echo "   🛑 停止 Systemd 服务: $SERVICE_NAME"
                            sudo systemctl stop "$SERVICE_NAME" 2>/dev/null || true
                            sudo systemctl disable "$SERVICE_NAME" 2>/dev/null || true
                        else
                            echo "   ⚠️  无法自动识别服务名，尝试暴力停止常见服务名..."
                            sudo systemctl stop telegram-ai 2>/dev/null || true
                            sudo systemctl stop next-server 2>/dev/null || true
                            sudo systemctl stop node-app 2>/dev/null || true
                            sudo systemctl stop frontend 2>/dev/null || true
                        fi
                    else
                        # 策略 B: 普通父进程 (如 PM2 God Daemon)，直接杀掉父进程
                        echo "🔪 杀掉父进程 (PID $PPID)..."
                        sudo kill -9 $PPID 2>/dev/null || true
                    fi
                fi
                # 杀掉子进程
                sudo kill -9 $PID 2>/dev/null || true
            fi

            # 同样处理端口 8000（使用与端口 3000 相同的逻辑）
            echo "🔍 深度诊断端口 8000..."
            PID_8000=$(sudo lsof -t -i:8000 2>/dev/null | head -1 || echo "")
            if [ -n "$PID_8000" ]; then
                echo "⚠️  发现端口 8000 被 PID $PID_8000 占用"

                # 获取父进程 ID
                PPID_8000=$(ps -o ppid= -p $PID_8000 2>/dev/null | tr -d ' ' || echo "")
                if [ -n "$PPID_8000" ]; then
                    echo "   该进程由父进程 PID $PPID_8000 管理"
                    # 打印父进程详情
                    ps -f -p $PPID_8000 2>/dev/null || echo "   无法获取父进程详情"

                    # 策略 A: 如果父进程是 Systemd (PID 1)，说明是系统服务
                    if [ "$PPID_8000" -eq "1" ]; then
                        echo "🚨 发现 Systemd 服务在运行！正在尝试定位并停止..."
                        # 尝试通过 systemctl status 查找服务名
                        SERVICE_NAME=$(sudo systemctl status $PID_8000 2>/dev/null | grep -o "Loaded: loaded (/.*" | awk '{print $3}' | xargs basename 2>/dev/null | cut -d';' -f1 || echo "")
                        if [ -n "$SERVICE_NAME" ] && [ "$SERVICE_NAME" != "" ]; then
                            echo "   🛑 停止 Systemd 服务: $SERVICE_NAME"
                            sudo systemctl stop "$SERVICE_NAME" 2>/dev/null || true
                            sudo systemctl disable "$SERVICE_NAME" 2>/dev/null || true
                        else
                            echo "   ⚠️  无法自动识别服务名，尝试暴力停止常见服务名..."
                            sudo systemctl stop telegram-ai 2>/dev/null || true
                            sudo systemctl stop backend 2>/dev/null || true
                            sudo systemctl stop api-server 2>/dev/null || true
                        fi
                    else
                        # 策略 B: 普通父进程 (如 PM2 God Daemon)，直接杀掉父进程
                        echo "🔪 杀掉父进程 (PID $PPID_8000)..."
                        sudo kill -9 $PPID_8000 2>/dev/null || true
                    fi
                fi
                # 杀掉子进程
                sudo kill -9 $PID_8000 2>/dev/null || true
            fi

            # 3. 执行常规清理（双重保险）
            echo "🧹 执行常规清理..."
            sudo -u ubuntu pm2 kill 2>/dev/null || true
            sudo pm2 kill 2>/dev/null || true
            sudo killall -9 node 2>/dev/null || true
            sudo fuser -k -9 3000/tcp 2>/dev/null || true
            sudo fuser -k -9 8000/tcp 2>/dev/null || true

            # 4. 等待释放（多次重试）
            echo "⏳ 等待端口释放..."
            sleep 5

            # 5. 最终检查（带重试机制）
            PORT_3000_CLEAN=false
            PORT_8000_CLEAN=false
            
            # 最多重试 3 次
            for i in 1 2 3; do
                if [ "$PORT_3000_CLEAN" = "false" ]; then
                    if sudo lsof -i:3000 >/dev/null 2>&1; then
                        echo "⚠️  端口 3000 仍被占用（重试 $i/3），再次清理..."
                        sudo lsof -i:3000 | head -5 || true
                        PID=$(sudo lsof -t -i:3000 2>/dev/null | head -1 || echo "")
                        if [ -n "$PID" ]; then
                            PPID=$(ps -o ppid= -p $PID 2>/dev/null | tr -d ' ' || echo "")
                            if [ -n "$PPID" ] && [ "$PPID" -ne "1" ]; then
                                sudo kill -9 $PPID 2>/dev/null || true
                            fi
                            sudo kill -9 $PID 2>/dev/null || true
                        fi
                        sudo fuser -k -9 3000/tcp 2>/dev/null || true
                        sleep 3
                    else
                        PORT_3000_CLEAN=true
                        echo "✅ 端口 3000 已彻底释放"
                    fi
                fi

                if [ "$PORT_8000_CLEAN" = "false" ]; then
                    if sudo lsof -i:8000 >/dev/null 2>&1; then
                        echo "⚠️  端口 8000 仍被占用（重试 $i/3），再次清理..."
                        sudo lsof -i:8000 | head -5 || true
                        PID_8000=$(sudo lsof -t -i:8000 2>/dev/null | head -1 || echo "")
                        if [ -n "$PID_8000" ]; then
                            PPID_8000=$(ps -o ppid= -p $PID_8000 2>/dev/null | tr -d ' ' || echo "")
                            if [ -n "$PPID_8000" ] && [ "$PPID_8000" -ne "1" ]; then
                                sudo kill -9 $PPID_8000 2>/dev/null || true
                            fi
                            sudo kill -9 $PID_8000 2>/dev/null || true
                        fi
                        sudo fuser -k -9 8000/tcp 2>/dev/null || true
                        sleep 3
                    else
                        PORT_8000_CLEAN=true
                        echo "✅ 端口 8000 已彻底释放"
                    fi
                fi

                # 如果两个端口都已清理，提前退出循环
                if [ "$PORT_3000_CLEAN" = "true" ] && [ "$PORT_8000_CLEAN" = "true" ]; then
                    break
                fi
            done

            # 最终验证
            if [ "$PORT_3000_CLEAN" = "false" ]; then
                echo "❌ 严重错误：端口 3000 仍被占用，无法继续！"
                echo "占用端口的进程详情："
                sudo lsof -i:3000 || true
                exit 1
            fi

            if [ "$PORT_8000_CLEAN" = "false" ]; then
                echo "❌ 严重错误：端口 8000 仍被占用，无法继续！"
                echo "占用端口的进程详情："
                sudo lsof -i:8000 || true
                exit 1
            fi

            # 6. 启动服务
            echo "🚀 启动 PM2 服务..."
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 start ecosystem.config.js"
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 save"

            # 等待启动
            echo "⏳ 等待服务初始化 (10秒)..."
            sleep 10
            
            # 显示 PM2 状态
            echo ""
            echo "📊 PM2 进程列表："
            sudo -u ubuntu pm2 list

            # 检查前端服务是否成功启动
            if sudo -u ubuntu pm2 list 2>/dev/null | grep -q "frontend.*errored"; then
                echo ""
                echo "❌ 前端服务启动失败，查看错误日志："
                sudo -u ubuntu pm2 logs frontend --lines 30 --nostream 2>&1 || true
                echo ""
                echo "⚠️  前端服务启动失败，部署将继续但需要手动检查"
            fi

            # 保存 PM2 配置
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 save"

            # 重启 Nginx
            echo "🔄 重启 Nginx..."
            sudo systemctl restart nginx
            
            # 配置 Nginx
            echo ""
            echo "🌐 配置 Nginx 反向代理..."

            # 创建 Nginx 配置文件（从仓库中的配置文件复制）
            NGINX_CONFIG_FILE="/etc/nginx/sites-available/aikz.usdt2026.cc"
            
            # 确定实际的 standalone 目录路径（用于静态资源 alias）
            # 从之前构建步骤中，我们知道 STANDALONE_DIR 是在 saas-demo 目录下
            cd saas-demo || exit 1
            ACTUAL_STANDALONE_DIR=""
            if [ -d ".next/standalone" ]; then
                if [ -d ".next/standalone/saas-demo" ]; then
                    ACTUAL_STANDALONE_DIR=".next/standalone/saas-demo"
                elif [ -f ".next/standalone/server.js" ]; then
                    ACTUAL_STANDALONE_DIR=".next/standalone"
                else
                    ACTUAL_STANDALONE_DIR=$(find .next/standalone -type f -name "server.js" 2>/dev/null | head -1 | xargs dirname 2>/dev/null || echo ".next/standalone")
                fi
            fi
            cd ..
            
            # 构建完整的静态资源路径
            STATIC_PATH="/home/ubuntu/telegram-ai-system/saas-demo/${ACTUAL_STANDALONE_DIR}/.next/static"
            PUBLIC_PATH="/home/ubuntu/telegram-ai-system/saas-demo/${ACTUAL_STANDALONE_DIR}/public"
            
            echo "📂 静态资源路径: $STATIC_PATH"
            echo "📂 公共资源路径: $PUBLIC_PATH"

            # 优先使用 deploy/nginx/aikz.conf（现在使用 proxy_pass，不需要替换路径）
            if [ -f "deploy/nginx/aikz.conf" ]; then
                sudo cp deploy/nginx/aikz.conf "$NGINX_CONFIG_FILE"
                echo "✅ 从 deploy/nginx/aikz.conf 复制 Nginx 配置"
            elif [ -f "deploy/nginx_websocket_config.conf" ]; then
                sudo cp deploy/nginx_websocket_config.conf "$NGINX_CONFIG_FILE"
                echo "✅ 从 deploy/nginx_websocket_config.conf 复制 Nginx 配置"
            else
                # 使用简化的配置（避免 heredoc 问题），但加入静态资源处理
                echo "正在生成优化后的 Nginx 配置..."
                
                # 确保 USER 变量正确（在 GitHub Actions 中，USER 可能是 runner，需要显式设置）
                USER="ubuntu"
                
                # 1. 开始写入配置
                echo "server {" | sudo tee "$NGINX_CONFIG_FILE" > /dev/null
                echo "    listen 80;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "    server_name aikz.usdt2026.cc;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                
                # 2. 关键修复：静态资源代理到 Next.js 服务器（使用 proxy_pass）
                echo "    location /_next/static {" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_pass http://127.0.0.1:3000;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_http_version 1.1;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Host \$host;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Real-IP \$remote_addr;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Forwarded-Proto \$scheme;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        expires 365d;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        access_log off;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "    }" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                
                # 3. 公共资源处理（同样使用 proxy_pass）
                echo "    location /public {" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_pass http://127.0.0.1:3000;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_http_version 1.1;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Host \$host;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Real-IP \$remote_addr;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Forwarded-Proto \$scheme;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        expires 30d;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        access_log off;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "    }" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                
                # 4. 主应用转发
                echo "    location / {" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_pass http://127.0.0.1:3000;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_http_version 1.1;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Upgrade \$http_upgrade;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Connection 'upgrade';" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Host \$host;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_cache_bypass \$http_upgrade;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "    }" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                
                # 5. API 转发
                echo "    location /api/ {" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_pass http://127.0.0.1:8000/api/;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_http_version 1.1;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header Host \$host;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Real-IP \$remote_addr;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "    }" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                
                echo "}" | sudo tee -a "$NGINX_CONFIG_FILE" > /dev/null
                echo "✅ Nginx 配置已更新 (包含静态资源优化)"
            fi
            
            # 创建符号链接到 sites-enabled（如果不存在）
            if [ ! -f "/etc/nginx/sites-enabled/aikz.usdt2026.cc" ]; then
                sudo ln -s "$NGINX_CONFIG_FILE" /etc/nginx/sites-enabled/aikz.usdt2026.cc
                echo "✅ 创建 Nginx 配置符号链接"
            fi
            
            # 禁用默认站点（如果存在）
            sudo rm -f /etc/nginx/sites-enabled/default
            
            # 测试 Nginx 配置
            if sudo nginx -t; then
                echo "✅ Nginx 配置测试通过"
            else
                echo "❌ Nginx 配置测试失败"
                exit 1
            fi
            
            # 重启 Nginx
            echo ""
            echo "🔄 重启 Nginx..."
            sudo systemctl restart nginx
            sleep 2
            
            # 检查 Nginx 状态
            if sudo systemctl is-active --quiet nginx; then
                echo "✅ Nginx 运行正常"
            else
                echo "❌ Nginx 启动失败"
                sudo systemctl status nginx --no-pager -l | head -20 || true
            fi
            
            # 6. 验证服务状态 (使用 JSON 方式)
            echo ""
            echo "🔍 验证服务状态..."

            # 完全禁用 set -e 进行验证（避免任何命令失败导致脚本退出）
            set +e

            # 获取 PM2 的 JSON 输出（最稳健的方式）
            PM2_JSON=$(sudo -u ubuntu pm2 jlist 2>/dev/null || echo "[]")

            # 定义检查函数（使用 grep 在 JSON 中查找特定模式）
            check_status_json() {
                local service_name=$1
                
                # 先检查服务是否存在
                if ! echo "$PM2_JSON" | grep -q "\"name\":\"$service_name\""; then
                    echo "  ❌ $service_name 服务: 未找到（可能未启动）"
                    return 1
                fi
                
                # 提取 status 字段值
                # PM2 JSON 格式：{"name":"service_name",...,"pm2_env":{"status":"online",...},...}
                # 使用 sed 提取 status 值（查找 name 后的第一个 status 字段）
                SERVICE_STATUS=$(echo "$PM2_JSON" | sed -n "s/.*\"name\":\"$service_name\"[^}]*\"pm2_env\":{[^}]*\"status\":\"\([^\"]*\)\".*/\1/p" | head -1)
                
                # 如果上面的方法失败，尝试更宽松的匹配（不依赖 pm2_env 结构）
                if [ -z "$SERVICE_STATUS" ]; then
                    # 查找 name 后的任何 status 字段
                    SERVICE_STATUS=$(echo "$PM2_JSON" | sed -n "s/.*\"name\":\"$service_name\"[^{]*{[^}]*\"status\":\"\([^\"]*\)\".*/\1/p" | head -1)
                fi
                
                # 如果还是找不到，设为未知
                if [ -z "$SERVICE_STATUS" ]; then
                    SERVICE_STATUS="未知"
                fi
                
                # 检查状态是否为 online
                if [ "$SERVICE_STATUS" = "online" ]; then
                    echo "  ✅ $service_name 服务: online"
                    return 0
                else
                    echo "  ❌ $service_name 服务: 状态异常"
                    echo "     📊 当前状态: $SERVICE_STATUS"
                    
                    # 打印最后日志
                    echo "     📜 最近日志:"
                    sudo -u ubuntu pm2 logs "$service_name" --lines 15 --nostream 2>&1 | head -20 || true
                    return 1
                fi
            }

            # 执行检查
            EXIT_CODE=0
            echo ""
            echo "📊 服务状态检查："
            check_status_json "backend" || EXIT_CODE=1
            check_status_json "frontend" || EXIT_CODE=1

            # 最终结果判断
            echo ""
            if [ $EXIT_CODE -eq 0 ]; then
                echo "🎉🎉🎉 部署圆满成功！所有服务均已在线！"
                # 再次打印简表供人工确认
                echo ""
                echo "📋 PM2 进程列表（确认用）："
                sudo -u ubuntu pm2 list 2>&1 || true
            else
                echo "❌ 部署完成，但有服务未正常启动。"
            fi

            # 退出脚本（确保有明确的退出码）
            exit $EXIT_CODE
