# 服務器上直接執行完整檢查（無需文件）

> **日期**: 2025-12-01  
> **用途**: 直接在服務器上執行檢查，無需等待文件同步

---

## 🚀 完整檢查命令（複製粘貼）

在服務器終端執行以下完整命令：

```bash
echo "=========================================" && \
echo "系統完整性檢查" && \
echo "=========================================" && \
echo "" && \
echo "【1】檢查後端服務..." && \
BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health 2>/dev/null || echo "000") && \
if [ "$BACKEND_STATUS" = "200" ]; then \
  echo "✓ 後端服務運行正常 (HTTP $BACKEND_STATUS)" && \
  curl -s http://localhost:8000/health && echo ""; \
else \
  echo "✗ 後端服務異常 (HTTP $BACKEND_STATUS)"; \
fi && \
echo "" && \
echo "【2】檢查前端服務..." && \
FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000") && \
if [ "$FRONTEND_STATUS" = "200" ] || [ "$FRONTEND_STATUS" = "304" ]; then \
  echo "✓ 前端服務運行正常 (HTTP $FRONTEND_STATUS)"; \
else \
  echo "⚠ 前端服務異常 (HTTP $FRONTEND_STATUS)"; \
fi && \
echo "" && \
echo "【3】檢查數據庫連接..." && \
cd ~/liaotian/admin-backend && \
source .venv/bin/activate 2>/dev/null && \
if python3 -c "from app.db import SessionLocal; db = SessionLocal(); print('✓ 數據庫連接成功'); db.close()" 2>&1; then \
  echo "✓ 數據庫連接正常"; \
else \
  echo "✗ 數據庫連接失敗"; \
fi && \
echo "" && \
echo "【4】檢查關鍵 API 端點..." && \
DOCS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/docs 2>/dev/null || echo "000") && \
if [ "$DOCS_STATUS" = "200" ]; then \
  echo "✓ API 文檔可訪問"; \
else \
  echo "⚠ API 文檔不可訪問 (HTTP $DOCS_STATUS)"; \
fi && \
SCRIPTS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/v1/group-ai/scripts/ 2>/dev/null || echo "000") && \
echo "  劇本列表 API: HTTP $SCRIPTS_STATUS" && \
echo "" && \
echo "【5】檢查服務進程..." && \
UVICORN_COUNT=$(ps aux | grep uvicorn | grep -v grep | wc -l) && \
echo "  uvicorn 進程數: $UVICORN_COUNT" && \
if [ "$UVICORN_COUNT" -gt 1 ]; then \
  echo "  ⚠ 發現多個進程，建議清理"; \
fi && \
NEXT_COUNT=$(ps aux | grep next | grep -v grep | wc -l) && \
echo "  next 進程數: $NEXT_COUNT" && \
echo "" && \
echo "【6】檢查端口占用..." && \
PORT_8000=$(lsof -ti:8000 2>/dev/null | wc -l) && \
PORT_3000=$(lsof -ti:3000 2>/dev/null | wc -l) && \
if [ "$PORT_8000" -gt 0 ]; then \
  echo "✓ 端口 8000 已被占用"; \
else \
  echo "✗ 端口 8000 未被占用"; \
fi && \
if [ "$PORT_3000" -gt 0 ]; then \
  echo "✓ 端口 3000 已被占用"; \
else \
  echo "⚠ 端口 3000 未被占用"; \
fi && \
echo "" && \
echo "=========================================" && \
echo "檢查完成" && \
echo "========================================="
```

---

## 📋 簡化版本（分步執行）

如果上面的命令太長，可以分步執行：

### 步驟 1: 後端和前端檢查

```bash
echo "【1】後端服務:" && curl -s http://localhost:8000/health && echo "" && \
echo "【2】前端服務:" && curl -s -o /dev/null -w "HTTP %{http_code}\n" http://localhost:3000
```

### 步驟 2: 數據庫檢查

```bash
cd ~/liaotian/admin-backend && \
source .venv/bin/activate && \
python3 -c "from app.db import SessionLocal; db = SessionLocal(); print('✓ 數據庫正常'); db.close()"
```

### 步驟 3: 進程和端口檢查

```bash
echo "【進程檢查】" && \
echo "uvicorn: $(ps aux | grep uvicorn | grep -v grep | wc -l) 個" && \
echo "next: $(ps aux | grep next | grep -v grep | wc -l) 個" && \
echo "" && \
echo "【端口檢查】" && \
lsof -ti:8000 && echo "✓ 端口8000已占用" || echo "✗ 端口8000未占用" && \
lsof -ti:3000 && echo "✓ 端口3000已占用" || echo "✗ 端口3000未占用"
```

---

## 📊 檢查結果判斷

### ✅ 正常情況

- 後端服務: HTTP 200, 響應 `{"status":"ok"}`
- 數據庫: 連接成功
- 進程: 1-2 個 uvicorn 進程（正常）
- 端口: 8000 和 3000 都被占用

### ⚠️ 警告情況

- 前端服務不可訪問（可能是未啟動）
- 多個 uvicorn 進程（建議清理）

### ❌ 錯誤情況

- 後端服務不可訪問
- 數據庫連接失敗
- 關鍵端口未被占用

---

**執行後告訴我結果，我們繼續下一步！**
