# 创建剧本 HTTP 500 错误分析

## 问题现象

前端在创建剧本时，`POST /api/v1/group-ai/scripts` 接口返回 **HTTP 500 Internal Server Error**。

**前端请求的 YAML 内容示例：**
```yaml
script_id:
version: "1.0"
description:
metadata:
roles:
  - id: si
    name:
    personality: "话多、爱开玩笑,比较外向"
  - id: huge
    name: "浩哥"
    personality: "看上去严肃,其实很温柔,负责照顾新人"
  - id: user_default
    name: "大家"
    personality: "普通群友,偶尔插两句嘴、氛围轻松"
```

**注意：** 这是一个**旧格式**的 YAML（包含 `roles` 而不是 `scenes`），需要转换为新格式。

## 相关代码

### 1. 创建剧本接口 (`admin-backend/app/api/group_ai/scripts.py`)

```python
@router.post("/", response_model=ScriptResponse, status_code=status.HTTP_201_CREATED)
async def create_script(
    request: ScriptCreateRequest,
    current_user=Depends(get_current_active_user),
    db: Session = Depends(get_db)
):
    """創建劇本（需要 script:create 權限）"""
    check_permission(current_user, PermissionCode.SCRIPT_CREATE.value, db)
    invalidate_cache("scripts_list")
    temp_path = None
    try:
        # 使用统一的 YAML 规范化函数，自动处理各种格式
        normalized_yaml, final_script_id, final_version, final_description = normalize_script_yaml(
            raw_yaml=request.yaml_content,
            script_id=request.script_id,
            script_name=request.name
        )
        # ... 后续处理
```

### 2. YAML 规范化函数 (`normalize_script_yaml`)

```python
def normalize_script_yaml(
    raw_yaml: str,
    script_id: Optional[str] = None,
    script_name: Optional[str] = None
) -> Tuple[str, Optional[str], Optional[str], Optional[str]]:
    """
    将任意格式的剧本 YAML 转换为标准格式
    """
    try:
        # 第一步：使用增强转换器进行格式检测和转换
        try:
            # convert_with_enhanced_detection 返回 (converted_data, warnings) 元组
            converted_data, warnings = enhanced_converter.convert_with_enhanced_detection(
                content=raw_yaml,
                script_id=script_id,
                script_name=script_name
            )
            if not isinstance(converted_data, dict):
                raise ValueError("转换后的数据不是字典格式")
            conversion_info = {"method": "enhanced_converter", "warnings": warnings}
            logger.debug(f"格式转换完成: {conversion_info}")
        except Exception as e:
            logger.warning(f"增强转换失败，尝试基础转换: {e}")
            # 降级到基础转换器
            # ...
        
        # 第二步：使用增强转换器进行结构校验和修复
        try:
            validated_data, validation_warnings = enhanced_converter.validate_and_fix(converted_data)
            # ...
        except Exception as e:
            logger.warning(f"YAML 结构验证失败，使用转换后的内容: {e}")
            validated_data = converted_data
            validation_warnings = []
        
        # 第三步：提取元数据并输出统一格式
        # ...
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"YAML 规范化失败: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"YAML 规范化处理失败: {str(e)}"
        )
```

### 3. 增强转换器 (`group_ai_service/enhanced_format_converter.py`)

```python
def convert_with_enhanced_detection(
    self,
    content: str,
    script_id: Optional[str] = None,
    script_name: Optional[str] = None
) -> Dict[str, Any]:
    """
    使用增强检测进行转换
    返回类型声明为 Dict[str, Any]，但实际返回 (data, warnings) 元组
    """
    # ... 检测格式
    # ... 转换逻辑
    return converted, warnings  # 实际返回元组，但类型声明不匹配
```

## 已尝试的修复

1. ✅ **修复了 `convert_with_enhanced_detection` 返回值处理**
   - 代码中假设返回 `(converted_data, warnings)` 元组
   - 但类型声明为 `Dict[str, Any]`，可能存在不一致

2. ✅ **添加了详细的错误日志**
   - 在 `create_script` 中添加了完整的异常堆栈跟踪
   - 在 `normalize_script_yaml` 中添加了错误日志

3. ✅ **修复了 `ScriptResponse` 构建逻辑**
   - 确保所有字段都有默认值
   - 处理了 `created_at` 和 `updated_at` 的 `None` 情况

## 可能的原因

### 1. 类型不匹配问题 ⚠️ **最可能**
- `convert_with_enhanced_detection` 的类型声明是 `Dict[str, Any]`，但实际返回 `(data, warnings)` 元组
- 如果某些代码路径只返回字典，会导致解包失败：`converted_data, warnings = ...` 会抛出 `ValueError: too many values to unpack`

### 2. 旧格式转换失败
- 用户提供的 YAML 是旧格式（包含 `roles` 而不是 `scenes`）
- `convert_with_enhanced_detection` 可能无法正确转换这种格式
- 转换后的数据可能缺少必需的字段（如 `scenes`）

### 3. `validate_and_fix` 失败
- `enhanced_converter.validate_and_fix(converted_data)` 可能抛出未捕获的异常
- 虽然代码中有 `try-except`，但可能某些异常类型未被正确捕获

### 4. YAML 解析失败
- `yaml.dump(validated_data, ...)` 可能失败
- 如果 `validated_data` 包含不可序列化的对象

### 5. 数据库操作失败
- `db.add(db_script)` 或 `db.commit()` 可能失败
- 但错误应该被捕获并返回 400 或 500，而不是静默失败

## 需要的信息

1. **后端完整错误日志**（运行 uvicorn 的终端窗口）
   - 完整的堆栈跟踪
   - 错误发生的具体行号
   - 异常类型和消息

2. **前端 Network 面板信息**
   - `POST /api/v1/group-ai/scripts` 请求的完整 Request Payload
   - Response Body（错误详情）
   - Response Headers

3. **测试数据**
   - 用户实际提交的完整 YAML 内容
   - 请求中的所有字段值

## 调试建议

### 1. 检查 `convert_with_enhanced_detection` 的返回值

在 `normalize_script_yaml` 中添加调试代码：

```python
try:
    result = enhanced_converter.convert_with_enhanced_detection(
        content=raw_yaml,
        script_id=script_id,
        script_name=script_name
    )
    logger.debug(f"convert_with_enhanced_detection 返回类型: {type(result)}")
    logger.debug(f"返回值: {result}")
    
    # 检查返回值类型
    if isinstance(result, tuple):
        if len(result) == 2:
            converted_data, warnings = result
        else:
            raise ValueError(f"返回值元组长度不正确: {len(result)}")
    elif isinstance(result, dict):
        # 如果只返回字典，没有 warnings
        converted_data = result
        warnings = []
    else:
        raise ValueError(f"意外的返回值类型: {type(result)}")
except Exception as e:
    logger.error(f"convert_with_enhanced_detection 调用失败: {e}", exc_info=True)
    raise
```

### 2. 检查转换后的数据结构

```python
logger.debug(f"转换后的数据: {converted_data}")
logger.debug(f"转换后的数据类型: {type(converted_data)}")
logger.debug(f"转换后的数据键: {converted_data.keys() if isinstance(converted_data, dict) else 'N/A'}")
```

### 3. 检查 `validate_and_fix` 的返回值

```python
try:
    result = enhanced_converter.validate_and_fix(converted_data)
    logger.debug(f"validate_and_fix 返回类型: {type(result)}")
    if isinstance(result, tuple) and len(result) == 2:
        validated_data, validation_warnings = result
    else:
        raise ValueError(f"validate_and_fix 返回值格式不正确: {type(result)}")
except Exception as e:
    logger.error(f"validate_and_fix 失败: {e}", exc_info=True)
    raise
```

### 4. 添加更详细的异常处理

在 `create_script` 的每个关键步骤添加 try-except：

```python
try:
    normalized_yaml, final_script_id, final_version, final_description = normalize_script_yaml(...)
except HTTPException:
    raise
except Exception as e:
    logger.error(f"normalize_script_yaml 失败: {e}", exc_info=True)
    raise HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail=f"YAML 规范化失败: {str(e)}"
    )
```

## 快速修复建议

### 方案 1：修复返回值类型不匹配

修改 `normalize_script_yaml` 中的返回值处理，使其能够处理两种返回格式：

```python
result = enhanced_converter.convert_with_enhanced_detection(
    content=raw_yaml,
    script_id=script_id,
    script_name=script_name
)

# 处理返回值：可能是元组或字典
if isinstance(result, tuple) and len(result) == 2:
    converted_data, warnings = result
elif isinstance(result, dict):
    converted_data = result
    warnings = []
else:
    raise ValueError(f"convert_with_enhanced_detection 返回了意外的类型: {type(result)}")
```

### 方案 2：修复类型声明

修改 `enhanced_format_converter.py` 中的类型声明，使其与实际返回值一致：

```python
def convert_with_enhanced_detection(
    self,
    content: str,
    script_id: Optional[str] = None,
    script_name: Optional[str] = None
) -> Tuple[Dict[str, Any], List[str]]:  # 修改返回类型为元组
    """
    使用增强检测进行转换
    
    Returns:
        Tuple[Dict[str, Any], List[str]]: (converted_data, warnings)
    """
    # ... 实现
    return converted, warnings
```

## 下一步行动

1. **获取后端日志**：查看运行 uvicorn 的终端窗口，找到完整的错误堆栈跟踪
2. **获取前端 Network 信息**：在浏览器 DevTools 的 Network 面板中，找到失败的 `POST /api/v1/group-ai/scripts` 请求，查看 Request Payload 和 Response Body
3. **根据日志定位问题**：根据错误信息确定是哪个步骤失败（转换、验证、解析、数据库操作）
4. **应用相应的修复方案**：根据问题原因选择上述方案之一进行修复

