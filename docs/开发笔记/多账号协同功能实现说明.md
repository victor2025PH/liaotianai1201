# 多賬號協同功能實現說明

> **實現日期**: 2025-11-30  
> **狀態**: ✅ 已完成

---

## 📋 功能概述

多賬號協同管理器（CoordinationManager）用於協調多個賬號在同一群組中的對話，避免重複回復，實現角色互動序列管理。

---

## ✅ 已實現功能

### 1. 回復協調機制
- ✅ 防止多個賬號同時回復同一消息
- ✅ 基於角色的回復優先級選擇
- ✅ 回復鎖機制（TTL 30秒）
- ✅ 負載均衡（根據最近回復次數）

### 2. 角色互動序列
- ✅ 支持定義角色互動順序
- ✅ 優先級排序（HIGH/NORMAL/LOW）
- ✅ 根據序列自動分配優先級

### 3. 賬號註冊管理
- ✅ 賬號-角色映射
- ✅ 賬號-群組註冊
- ✅ 動態註冊/取消註冊

---

## 🔧 技術架構

### 核心組件

#### 1. CoordinationManager
**文件**: `group_ai_service/coordination_manager.py`

**主要功能**:
- 管理群組協調信息
- 判斷賬號是否應該回復
- 維護回復鎖
- 清理過期鎖

**關鍵方法**:
```python
async def should_reply(account_id, group_id, message) -> Tuple[bool, str]
async def on_reply_sent(account_id, group_id, message_id)
register_account_role(account_id, role_id, role_name, priority)
set_role_sequence(group_id, role_sequence)
```

#### 2. 集成到 DialogueManager
**修改**: `group_ai_service/dialogue_manager.py`

**集成點**:
- 在 `process_message` 開始時檢查協同管理器
- 在回復生成後通知協同管理器
- 在 `initialize_account` 時註冊賬號角色

#### 3. 集成到 ServiceManager
**修改**: `group_ai_service/service_manager.py`

**集成點**:
- 初始化時創建 CoordinationManager
- 啟動協同管理器
- 從賬號配置中獲取角色ID並註冊

---

## 📝 使用方式

### 1. 基本使用（自動啟用）

當賬號啟動時，如果配置了角色分配，協同管理器會自動工作：

```python
# 賬號配置中包含角色信息
account.config.metadata = {
    'assigned_role_id': 'role_1',
    'script_id': 'multi_role_script'
}

# 啟動賬號時，協同管理器會自動：
# 1. 註冊賬號到群組
# 2. 註冊賬號角色
# 3. 在回復前檢查協同邏輯
```

### 2. 設置角色互動序列

```python
from group_ai_service.service_manager import ServiceManager

service_manager = ServiceManager.get_instance()

# 設置群組的角色互動序列
service_manager.coordination_manager.set_role_sequence(
    group_id=-1001234567890,
    role_sequence=['role_1', 'role_2', 'role_3']
)

# 結果：
# - role_1 優先級為 HIGH（第一個回復）
# - role_2 和 role_3 優先級為 NORMAL
# - 當有消息時，role_1 會優先回復
```

### 3. 手動註冊賬號角色

```python
# 註冊賬號角色
service_manager.coordination_manager.register_account_role(
    account_id='account_001',
    role_id='role_1',
    role_name='客服小助手',
    priority=ReplyPriority.HIGH
)

# 註冊賬號到群組
service_manager.coordination_manager.register_account_to_group(
    account_id='account_001',
    group_id=-1001234567890
)
```

---

## 🔄 工作流程

### 消息處理流程

```
1. 群組收到新消息
   ↓
2. 所有監聽該群組的賬號都會收到消息
   ↓
3. 每個賬號的 DialogueManager.process_message 被調用
   ↓
4. DialogueManager 調用 CoordinationManager.should_reply()
   ↓
5. CoordinationManager 判斷：
   - 是否有回復鎖？
   - 當前賬號是否是優先級最高的？
   - 是否應該由當前賬號回復？
   ↓
6. 如果應該回復：
   - 創建回復鎖
   - 生成回復
   - 發送回復
   - 通知協同管理器
   ↓
7. 如果不應該回復：
   - 返回 None，不生成回復
```

### 回復鎖機制

```
消息 ID: 12345
群組 ID: -1001234567890

時間線：
T0: 消息 12345 到達
T1: account_1 檢查協同管理器 -> 應該回復 -> 創建鎖（locked_account_id=account_1）
T2: account_2 檢查協同管理器 -> 發現已鎖定 -> 不回復
T3: account_1 發送回復 -> 通知協同管理器
T4: 鎖保留 30 秒（防止重複處理）
T5: 鎖過期，自動清理
```

---

## 📊 選擇邏輯

### 優先級排序規則

當多個賬號都匹配消息時，按以下順序選擇：

1. **角色序列優先級**
   - 如果設置了角色序列，序列中的第一個角色優先
   
2. **角色優先級**
   - HIGH > NORMAL > LOW > NONE

3. **負載均衡**
   - 最近回復次數少的優先

4. **最後回復時間**
   - 最後回復時間早的優先（避免總是同一個賬號回復）

### 示例

```
群組中有 3 個賬號：
- account_1 (role_1, 優先級: HIGH, 最近回復: 5次)
- account_2 (role_2, 優先級: NORMAL, 最近回復: 2次)
- account_3 (role_3, 優先級: NORMAL, 最近回復: 10次)

選擇結果：
1. account_1 優先（優先級 HIGH）
2. 如果 account_1 不匹配，選擇 account_2（負載更輕）
```

---

## 🎯 配置說明

### 角色優先級配置

```python
from group_ai_service.coordination_manager import ReplyPriority

# 設置角色優先級
coordination_manager.role_priorities['role_1'] = ReplyPriority.HIGH
coordination_manager.role_priorities['role_2'] = ReplyPriority.NORMAL
```

### 回復鎖TTL配置

```python
# 創建協同管理器時配置
coordination_manager = CoordinationManager(
    lock_ttl=30,  # 回復鎖TTL（秒）
    cleanup_interval=60  # 清理間隔（秒）
)
```

---

## ⚠️ 注意事項

### 1. 角色分配必須配置

協同管理器依賴賬號的角色信息，確保：
- 賬號配置中包含 `metadata['assigned_role_id']`
- 在啟動賬號前完成角色分配

### 2. 協同管理器是全局單例

- 每個 ServiceManager 實例共享同一個 CoordinationManager
- 所有群組的協同邏輯統一管理

### 3. 回復鎖自動清理

- 回復鎖有 TTL（默認 30 秒）
- 清理任務每 60 秒運行一次
- 無需手動清理

---

## 🐛 調試方法

### 查看協同狀態

```python
# 查看群組中的所有賬號
accounts = coordination_manager.get_group_accounts(group_id)
for acc in accounts:
    print(f"賬號: {acc.account_id}, 角色: {acc.role_id}, 優先級: {acc.priority}")

# 查看賬號角色
role_id = coordination_manager.get_account_role(account_id)
print(f"賬號 {account_id} 的角色: {role_id}")
```

### 日誌查看

協同管理器會輸出詳細日誌：
- `協同管理器決定不回復`: 某個賬號被協同邏輯阻止回復
- `創建回復鎖`: 某個賬號獲得了回復權
- `清理了 N 個過期回復鎖`: 清理任務運行

---

## 📈 性能考慮

### 1. 鎖管理
- 回復鎖存儲在內存中（字典）
- 每個消息最多創建一個鎖
- 自動過期清理，不會無限增長

### 2. 選擇算法
- 時間複雜度: O(n)，n 為群組中賬號數量
- 通常 n 較小（< 10），性能影響可忽略

### 3. 併發處理
- 使用 asyncio 鎖機制（通過回復鎖）
- 多個賬號可以並行檢查，但只有一個能獲取鎖

---

## 🔮 後續改進方向

### 1. 角色互動序列增強
- 支持條件序列（例如：role_1 說完後，role_2 根據條件決定是否回復）
- 支持序列超時（例如：role_1 3 秒內沒回復，role_2 可以回復）

### 2. 負載均衡優化
- 更智能的負載分配算法
- 考慮賬號在線狀態
- 考慮賬號歷史表現

### 3. 統計和監控
- 回復成功率統計
- 協同決策統計
- 鎖競爭統計

---

## ✅ 測試建議

### 1. 單賬號測試
- 確保單個賬號仍能正常工作
- 協同管理器不影響單賬號行為

### 2. 多賬號測試
- 創建 2-3 個賬號在同一群組
- 發送消息，觀察只有一個賬號回復
- 檢查日誌確認協同邏輯工作

### 3. 角色序列測試
- 設置角色序列
- 驗證序列中的第一個角色優先回復
- 驗證優先級排序正確

---

**實現完成時間**: 2025-11-30  
**文檔版本**: v1.0
