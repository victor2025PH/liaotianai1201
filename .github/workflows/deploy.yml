name: Deploy to Server

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.2.0
        continue-on-error: false
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 30m
          script_stop: true
          debug: true
          envs: GITHUB_REPO=${{ github.repository }},SERVER_HOST=${{ secrets.SERVER_HOST }}
          script: |
            # 遇到任何命令错误(非逻辑判断)则退出
            set -e
            
            PROJECT_DIR="/home/ubuntu/telegram-ai-system"
            
            echo "🚀 开始部署..."
            echo "时间: $(date)"
            echo "系统资源:"
            free -h || true
            echo ""
            
            # 0. 启用 Swap（如果未启用）
            echo "检查并启用 Swap..."
            sudo swapon /swapfile 2>/dev/null || echo "Swap 已启用或文件不存在"
            free -h || true
            echo ""
            
            # 1. 预检：如果目录存在但不是 git 仓库，先清理
            if [ -d "$PROJECT_DIR" ] && [ ! -d "$PROJECT_DIR/.git" ]; then
                echo "⚠️  发现无效项目目录（缺少 .git），正在清理..."
                sudo rm -rf "$PROJECT_DIR"
                echo "✅ 无效目录已清理"
            fi
            
            # 2. 检查并创建项目目录（如果不存在）
            if [ ! -d "$PROJECT_DIR" ]; then
                echo "项目目录不存在，正在创建并克隆代码..."
                sudo mkdir -p "$PROJECT_DIR"
                sudo chown -R ubuntu:ubuntu "$PROJECT_DIR"
                # 克隆代码
                sudo -u ubuntu git clone https://github.com/victor2025PH/liaotianai1201.git "$PROJECT_DIR"
                echo "✅ 代码克隆完成"
            fi
            
            # 3. 确保目录权限正确
            sudo chown -R ubuntu:ubuntu "$PROJECT_DIR" || true
            sudo chmod 755 "$PROJECT_DIR" || true
            
            # 4. 进入目录并更新代码
            cd "$PROJECT_DIR" || {
                echo "❌ 无法进入项目目录，检查权限..."
                ls -la "$PROJECT_DIR" || true
                exit 1
            }
            
            # 验证是 git 仓库
            if [ ! -d ".git" ]; then
                echo "❌ 错误：目录不是 git 仓库，这不应该发生"
                exit 1
            fi
            
            echo "📥 更新代码..."
            sudo -u ubuntu git fetch origin main
            sudo -u ubuntu git reset --hard origin/main
            echo "✅ 代码更新完成"
            
            # 2. 确保权限正确（再次确认）
            sudo chown -R ubuntu:ubuntu "$PROJECT_DIR" || true
            
            # 3. 构建前端
            echo "📦 构建前端..."
            cd saas-demo
            
            # 1. 清理锁文件（不停止服务，减少中断时间）
            rm -f .next/lock
            
            # 2. 检查内存和 Swap
            echo "检查系统资源..."
            free -h || true
            echo ""
            echo "启用 Swap（如果未启用）..."
            sudo swapon /swapfile 2>/dev/null || echo "Swap 已启用或文件不存在"
            free -h || true
            echo ""
            
            # 3. 安装与构建（在服务运行的情况下构建）
            # 使用 NODE_OPTIONS 限制 Node.js 内存使用（512MB，更保守）
            export NODE_OPTIONS="--max-old-space-size=512"
            npm install --prefer-offline --no-audit
            
            # 构建时也限制内存
            NODE_OPTIONS="--max-old-space-size=512" npm run build
            
            # 暴力复制静态资源 (Standalone 补丁)
            echo "📂 处理静态资源..."
            mkdir -p .next/standalone/.next/static
            # 使用 || true 防止某些文件不存在导致报错
            cp -r .next/static/* .next/standalone/.next/static/ || true
            cp -r public .next/standalone/ || true
            cd ..
            
            # 4. 后端依赖
            echo "🐍 安装后端依赖..."
            
            # 1. 强制安装系统级依赖（不要检查，直接装，确保环境存在）
            echo "🔧 正在安装 Python3 和 venv 模块..."
            # 使用非交互模式防止卡住
            sudo DEBIAN_FRONTEND=noninteractive apt-get update -q
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y python3 python3-venv python3-pip
            
            cd admin-backend || exit 1
            
            # 2. 重建虚拟环境（先删后建，防止环境损坏）
            echo "📦 重建虚拟环境..."
            rm -rf venv
            python3 -m venv venv
            
            # 3. 激活环境（使用点号 . 代替 source，兼容所有 Shell）
            echo "🔌 激活虚拟环境..."
            if [ -f "venv/bin/activate" ]; then
                . venv/bin/activate
            else
                echo "❌ 严重错误：虚拟环境创建失败"
                exit 1
            fi
            
            # 4. 安装依赖
            echo "📥 安装 pip 依赖..."
            pip install --upgrade pip --quiet
            pip install -r requirements.txt --quiet
            
            echo "✅ 后端依赖安装完成"
            cd ..
            
            # 5. 重启服务（使用 PM2）
            echo "🔄 重启服务..."
            
            # 检查前端构建产物是否存在（Next.js standalone 模式要求）
            echo "🔍 检查前端构建产物..."
            if [ ! -f "saas-demo/.next/standalone/server.js" ]; then
                echo "❌ 错误：前端 standalone 构建产物不存在"
                echo "   路径: saas-demo/.next/standalone/server.js"
                echo "   请检查前端构建是否成功完成"
                echo "   当前目录: $(pwd)"
                echo "   saas-demo/.next 目录内容:"
                ls -la saas-demo/.next/ 2>/dev/null | head -20 || echo "   .next 目录不存在"
                exit 1
            fi
            echo "✅ 前端构建产物检查通过"
            
            # 确保日志目录存在
            mkdir -p logs || true
            sudo chown -R ubuntu:ubuntu logs || true
            
            # 切换到 ubuntu 用户执行 PM2 命令
            # 注意：PM2 需要以运行服务的用户身份执行
            
            # 先停止所有服务，确保端口被释放
            echo "🛑 停止所有 PM2 服务..."
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 stop all || true"
            
            # 等待一下确保端口释放
            sleep 2
            
            # 检查并杀掉占用端口 3000 的进程（如果有）
            echo "🔍 检查端口 3000 占用情况..."
            PORT_3000_PID=$(sudo lsof -ti:3000 2>/dev/null || echo "")
            if [ -n "$PORT_3000_PID" ]; then
                echo "⚠️  发现端口 3000 被占用 (PID: $PORT_3000_PID)，正在终止..."
                sudo kill -9 $PORT_3000_PID 2>/dev/null || true
                sleep 1
            fi
            
            # 检查并杀掉占用端口 8000 的进程（如果有）
            PORT_8000_PID=$(sudo lsof -ti:8000 2>/dev/null || echo "")
            if [ -n "$PORT_8000_PID" ]; then
                echo "⚠️  发现端口 8000 被占用 (PID: $PORT_8000_PID)，正在终止..."
                sudo kill -9 $PORT_8000_PID 2>/dev/null || true
                sleep 1
            fi
            
            # 删除所有 PM2 进程，确保干净启动
            echo "🗑️  清理所有 PM2 进程..."
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 delete all || true"
            
            # 等待一下确保清理完成
            sleep 1
            
            # 重新启动所有服务
            echo "🚀 启动 PM2 服务..."
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 start ecosystem.config.js"
            
            # 等待服务启动
            echo "⏳ 等待服务启动..."
            sleep 5
            
            # 显示 PM2 状态
            echo ""
            echo "📊 PM2 进程列表："
            sudo -u ubuntu pm2 list
            
            # 检查前端服务是否成功启动
            if sudo -u ubuntu pm2 list 2>/dev/null | grep -q "frontend.*errored"; then
                echo ""
                echo "❌ 前端服务启动失败，查看错误日志："
                sudo -u ubuntu pm2 logs frontend --lines 30 --nostream 2>&1 || true
                echo ""
                echo "⚠️  前端服务启动失败，部署将继续但需要手动检查"
            fi
            
            # 保存 PM2 配置
            sudo -u ubuntu bash -c "cd /home/ubuntu/telegram-ai-system && pm2 save"
            
            # 配置 Nginx
            echo ""
            echo "🌐 配置 Nginx 反向代理..."
            
            # 创建 Nginx 配置文件（使用 cat 和 heredoc，但通过管道传递以避免 YAML 解析问题）
            NGINX_CONFIG_FILE="/etc/nginx/sites-available/aikz.usdt2026.cc"
            cat > /tmp/nginx-config-temp.conf <<'NGINXEOF'
server {
    listen 80;
    server_name aikz.usdt2026.cc;
    client_max_body_size 50M;
    location /api/v1/notifications/ws {
        proxy_pass http://127.0.0.1:8000/api/v1/notifications/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
        proxy_buffering off;
    }
    location ~ ^/api/workers(/.*)?$ {
        proxy_pass http://127.0.0.1:8000/api/v1/workers$1;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    location /api/ {
        proxy_pass http://127.0.0.1:8000/api/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300;
    }
    location /health {
        proxy_pass http://127.0.0.1:8000/health;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }
    location /docs {
        proxy_pass http://127.0.0.1:8000/docs;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }
    location /openapi.json {
        proxy_pass http://127.0.0.1:8000/openapi.json;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 86400;
    }
}
NGINXEOF
            sudo mv /tmp/nginx-config-temp.conf "$NGINX_CONFIG_FILE"
            
            # 创建符号链接到 sites-enabled（如果不存在）
            if [ ! -f "/etc/nginx/sites-enabled/aikz.usdt2026.cc" ]; then
                sudo ln -s "$NGINX_CONFIG_FILE" /etc/nginx/sites-enabled/aikz.usdt2026.cc
                echo "✅ 创建 Nginx 配置符号链接"
            fi
            
            # 禁用默认站点（如果存在）
            sudo rm -f /etc/nginx/sites-enabled/default
            
            # 测试 Nginx 配置
            if sudo nginx -t; then
                echo "✅ Nginx 配置测试通过"
            else
                echo "❌ Nginx 配置测试失败"
                exit 1
            fi
            
            # 重启 Nginx
            echo ""
            echo "🔄 重启 Nginx..."
            sudo systemctl restart nginx
            sleep 2
            
            # 检查 Nginx 状态
            if sudo systemctl is-active --quiet nginx; then
                echo "✅ Nginx 运行正常"
            else
                echo "❌ Nginx 启动失败"
                sudo systemctl status nginx --no-pager -l | head -20 || true
            fi
            
            # 6. 验证服务状态
            echo ""
            echo "🔍 验证服务状态..."
            
            # 完全禁用 set -e 进行验证（避免任何命令失败导致脚本退出）
            set +e
            
            # 详细的服务检查
            echo ""
            echo "📊 服务状态检查："
            
            # 使用更可靠的方式检查服务状态（直接 grep PM2 list 输出）
            PM2_LIST_OUTPUT=$(sudo -u ubuntu pm2 list 2>/dev/null || echo "")
            
            if echo "$PM2_LIST_OUTPUT" | grep -q "backend.*online"; then
                BACKEND_STATUS="online"
                echo "  ✅ 后端服务: online"
            elif echo "$PM2_LIST_OUTPUT" | grep -q "backend.*errored"; then
                BACKEND_STATUS="errored"
                echo "  ❌ 后端服务: errored"
                echo "     查看后端日志:"
                sudo -u ubuntu pm2 logs backend --lines 10 --nostream 2>&1 || true
            else
                BACKEND_STATUS="unknown"
                echo "  ⚠️  后端服务: 状态未知"
            fi
            
            if echo "$PM2_LIST_OUTPUT" | grep -q "frontend.*online"; then
                FRONTEND_STATUS="online"
                echo "  ✅ 前端服务: online"
            elif echo "$PM2_LIST_OUTPUT" | grep -q "frontend.*errored"; then
                FRONTEND_STATUS="errored"
                echo "  ❌ 前端服务: errored"
                echo "     检查前端构建产物:"
                ls -la saas-demo/.next/standalone/server.js 2>/dev/null || echo "     ❌ server.js 不存在"
                echo "     查看前端日志:"
                sudo -u ubuntu pm2 logs frontend --lines 20 --nostream 2>&1 || true
            else
                FRONTEND_STATUS="unknown"
                echo "  ⚠️  前端服务: 状态未知"
            fi
            
            # 根据服务状态决定退出码（只有 errored 状态才返回错误码）
            EXIT_CODE=0
            if [ "$BACKEND_STATUS" = "errored" ] || [ "$FRONTEND_STATUS" = "errored" ]; then
                echo ""
                echo "❌ 有服务处于 errored 状态，部署失败"
                EXIT_CODE=1
            elif [ "$BACKEND_STATUS" = "online" ] && [ "$FRONTEND_STATUS" = "online" ]; then
                echo ""
                echo "✅ 所有服务运行正常，部署成功"
                EXIT_CODE=0
            else
                echo ""
                echo "⚠️  服务状态未知，但部署步骤已完成"
                EXIT_CODE=0  # 状态未知时也认为成功（避免误判）
            fi
            
            # 退出脚本（确保有明确的退出码）
            exit $EXIT_CODE
