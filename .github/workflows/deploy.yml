name: Deploy to Server

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 55m
          script_stop: true
          debug: true
          script: |
            set -x
            set -o pipefail
            # 不使用 set -e，因為它會與條件判斷 [ ] 產生衝突
            # 我們使用手動錯誤檢查來處理關鍵命令的失敗
            
            handle_error() {
              echo "❌ Error at: $1"
              echo "Exit code: $?"
              exit 1
            }
            
            echo "=========================================="
            echo "Starting deployment - $(date)"
            echo "=========================================="
            
            echo "Testing SSH connection..."
            if ! whoami; then
              echo "❌ SSH connection failed"
              handle_error "SSH connection test"
            fi
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            echo "✅ SSH connection successful"
            
            echo "=========================================="
            echo "Step 1: Check project directory"
            echo "=========================================="
            PROJECT_DIR="/home/ubuntu/telegram-ai-system"
            
            # 直接嘗試進入目錄，如果失敗則克隆
            if cd "$PROJECT_DIR" 2>/dev/null; then
              echo "✅ Project directory exists"
            else
              echo "Project directory not found, cloning..."
              cd /home/ubuntu || handle_error "cd to /home/ubuntu"
              if ! timeout 10m git clone https://github.com/${{ github.repository }}.git telegram-ai-system; then
                echo "❌ Git clone failed or timeout"
                handle_error "git clone"
              fi
              cd "$PROJECT_DIR" || handle_error "cd to project directory"
            fi
            
            # 清理 /home/ubuntu/ 下的重複文件（舊的手動部署遺留）
            echo ""
            echo "清理舊的部署文件（如果存在）..."
            # 顯式進入目錄，避免相對路徑問題
            cd /home/ubuntu 2>/dev/null || true
            
            for dir in admin-backend saas-demo deploy scripts; do
              target="/home/ubuntu/$dir"
              # 邏輯：如果目標存在且是目錄 (-d)，並且 它不是軟鏈接 (! -L)
              if [ -d "$target" ] && [ ! -L "$target" ]; then
                echo "⚠️  發現舊的部署目錄: $target"
                echo "   這可能是舊的手動部署遺留，建議手動檢查後刪除"
              fi || true
            done
            
            # 返回項目目錄
            cd "$PROJECT_DIR" || handle_error "cd to project directory"
            
            echo ""
            echo "=========================================="
            echo "Step 2: Pull latest code"
            echo "=========================================="
            if ! timeout 5m git fetch origin main; then
              echo "⚠️  Git fetch failed or timeout, retrying..."
              git remote set-url origin https://github.com/${{ github.repository }}.git
              if ! timeout 5m git fetch origin main; then
                echo "❌ Git fetch failed or timeout"
                handle_error "git fetch"
              fi
            fi
            if ! timeout 1m git reset --hard origin/main; then
              echo "❌ Git reset failed or timeout"
              handle_error "git reset"
            fi
            echo "✅ Code updated to latest version"
            timeout 10s git log -1 --oneline || true
            
            echo ""
            echo "=========================================="
            echo "Step 3: Update backend dependencies"
            echo "=========================================="
            if [ -d "admin-backend" ]; then
              cd admin-backend
              # 如果 venv 不存在或 activate 文件不存在，則重新創建
              if [ ! -d "venv" ] || [ ! -f "venv/bin/activate" ]; then
                echo "Creating virtual environment (venv is missing or broken)..."
                rm -rf venv  # 安全起見，先刪除可能存在的壞目錄
                # 嘗試創建虛擬環境，如果失敗則安裝 python3-venv 包
                if ! python3 -m venv venv 2>/dev/null; then
                  echo "python3-venv not available, installing python3-venv package..."
                  timeout 2m sudo apt-get update -qq && timeout 5m sudo apt-get install -y python3-venv || {
                    echo "❌ Failed to install python3-venv"
                    handle_error "install python3-venv"
                  }
                  # 重新嘗試創建虛擬環境
                  python3 -m venv venv || {
                    echo "❌ Failed to create virtual environment after installing python3-venv"
                    handle_error "create venv"
                  }
                fi
              fi
              
              # Check and install ffmpeg (Safe pattern for ssh-action)
              command -v ffmpeg >/dev/null 2>&1 || {
                echo "Installing system ffmpeg..."
                timeout 2m sudo apt-get update -qq
                timeout 5m sudo apt-get install -y ffmpeg
              }
              
              source venv/bin/activate
              echo "Updating Python packages..."
              timeout 2m pip install --quiet --upgrade pip || echo "⚠️  pip upgrade failed or timeout, continuing..."
              timeout 10m pip install --quiet -r requirements.txt --timeout=300 --cache-dir=/tmp/pip-cache || {
                echo "⚠️  Some dependencies failed or timeout, continuing..."
              }
              cd ..
              echo "✅ Backend dependencies updated"
            else
              echo "⚠️  admin-backend directory not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Step 4: Update Bot dependencies"
            echo "=========================================="
            if [ -f "requirements.txt" ]; then
              # 如果 venv 不存在或 activate 文件不存在，則重新創建
              if [ ! -d "venv" ] || [ ! -f "venv/bin/activate" ]; then
                echo "Creating virtual environment (venv is missing or broken)..."
                rm -rf venv  # 安全起見，先刪除可能存在的壞目錄
                # 嘗試創建虛擬環境，如果失敗則安裝 python3-venv 包
                if ! python3 -m venv venv 2>/dev/null; then
                  echo "python3-venv not available, installing python3-venv package..."
                  timeout 2m sudo apt-get update -qq && timeout 5m sudo apt-get install -y python3-venv || {
                    echo "❌ Failed to install python3-venv"
                    handle_error "install python3-venv"
                  }
                  # 重新嘗試創建虛擬環境
                  python3 -m venv venv || {
                    echo "❌ Failed to create virtual environment after installing python3-venv"
                    handle_error "create venv"
                  }
                fi
              fi
              
              # Check and install ffmpeg (Safe pattern for ssh-action)
              command -v ffmpeg >/dev/null 2>&1 || {
                echo "Installing system ffmpeg..."
                timeout 2m sudo apt-get update -qq
                timeout 5m sudo apt-get install -y ffmpeg
              }
              
              source venv/bin/activate
              timeout 2m pip install --quiet --upgrade pip || echo "⚠️  pip upgrade failed or timeout, continuing..."
              timeout 10m pip install --quiet -r requirements.txt --timeout=300 --cache-dir=/tmp/pip-cache || {
                echo "⚠️  Some dependencies failed or timeout, continuing..."
              }
              echo "✅ Bot dependencies updated"
            else
              echo "⚠️  Bot requirements.txt not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Step 5: Deploy frontend"
            echo "=========================================="
            if [ -d "saas-demo" ]; then
              cd saas-demo
              
              echo "Installing frontend dependencies..."
              if [ -d "node_modules" ]; then
                echo "Using incremental install..."
                timeout 15m npm ci --prefer-offline --no-audit --no-fund || timeout 15m npm install --prefer-offline --no-audit --no-fund || {
                  echo "⚠️  Dependency installation timeout or failed, continuing..."
                }
              else
                echo "First-time install..."
                timeout 20m npm install --prefer-offline --no-audit --no-fund || {
                  echo "⚠️  Dependency installation timeout or failed, continuing..."
                }
              fi
              
              echo "Building frontend project..."
              export NODE_OPTIONS="--max-old-space-size=2048"
              timeout 20m npm run build || {
                echo "⚠️  Build failed or timeout, but continuing..."
              }
              
              if [ -d ".next/standalone" ]; then
                echo "Preparing Standalone directory..."
                if [ -d "public" ]; then
                  cp -r public .next/standalone/ || true
                fi
                mkdir -p .next/standalone/.next
                if [ -d ".next/static" ]; then
                  cp -r .next/static .next/standalone/.next/ || true
                fi
                echo "✅ Standalone directory ready"
              else
                echo "⚠️  Standalone directory not found"
              fi
              
              cd ..
            else
              echo "⚠️  saas-demo directory not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Step 6: Update Nginx config"
            echo "=========================================="
            if [ -f "deploy/nginx/aikz.conf" ]; then
              sudo cp deploy/nginx/aikz.conf /etc/nginx/sites-available/aikz.conf
              sudo ln -sf /etc/nginx/sites-available/aikz.conf /etc/nginx/sites-enabled/aikz.conf
              if timeout 30s sudo nginx -t 2>/dev/null; then
                timeout 30s sudo systemctl reload nginx 2>/dev/null && echo "✅ Nginx config updated and reloaded" || echo "⚠️  Nginx reload failed or timeout"
              else
                echo "❌ Nginx config test failed or timeout"
              fi
            else
              echo "⚠️  deploy/nginx/aikz.conf not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Step 7: Deploy Systemd services"
            echo "=========================================="
            if [ -f "scripts/server/deploy-systemd.sh" ]; then
              timeout 5m sudo bash scripts/server/deploy-systemd.sh || echo "⚠️  Systemd deployment failed or timeout, continuing..."
            else
              echo "⚠️  deploy-systemd.sh not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Step 8: Restart services"
            echo "=========================================="
            
            echo "Restarting backend service..."
            # 优先使用 luckyred-api，否则使用 telegram-backend（使用变量捕获，避免 grep 退出码问题）
            SERVICE_LIST=$(timeout 5s systemctl list-units --type=service --no-legend 2>/dev/null || echo "")
            if echo "$SERVICE_LIST" | grep -q "luckyred-api" 2>/dev/null; then
              timeout 30s sudo systemctl restart luckyred-api && echo "✅ Backend (luckyred-api) restarted" || echo "⚠️  Backend restart failed or timeout"
            else
              timeout 30s sudo systemctl restart telegram-backend && echo "✅ Backend (telegram-backend) restarted" || echo "⚠️  Backend restart failed or timeout"
            fi
            
            echo "Restarting Bot service..."
            timeout 30s sudo systemctl restart telegram-bot && echo "✅ Bot restarted" || echo "⚠️  Bot restart failed or timeout"
            
            FRONTEND_SERVICE_NAME=""
            # 使用变量捕获，避免 grep 退出码问题
            SERVICE_LIST=$(timeout 10s systemctl list-units --type=service --no-legend 2>/dev/null || echo "")
            if echo "$SERVICE_LIST" | grep -q "liaotian-frontend" 2>/dev/null; then
              FRONTEND_SERVICE_NAME="liaotian-frontend"
            elif echo "$SERVICE_LIST" | grep -q "smart-tg-frontend" 2>/dev/null; then
              FRONTEND_SERVICE_NAME="smart-tg-frontend"
            fi
            
            if [ -n "$FRONTEND_SERVICE_NAME" ]; then
              echo "Restarting frontend service ($FRONTEND_SERVICE_NAME)..."
              timeout 30s sudo systemctl restart "$FRONTEND_SERVICE_NAME" && echo "✅ Frontend restarted" || echo "⚠️  Frontend restart failed or timeout"
            else
              echo "⚠️  Frontend systemd service not found"
            fi
            
            echo ""
            echo "Waiting for services to start (3 seconds)..."
            sleep 3
            
            echo ""
            echo "=========================================="
            echo "Step 9: Check service status"
            echo "=========================================="
            
            echo "Checking backend service..."
            # 默认目标服务
            TARGET_SERVICE="telegram-backend"
            
            # 使用 systemctl cat 检查 luckyred-api 是否存在
            # 这种方式不需要管道，不会触发 SIGPIPE 错误
            if systemctl cat luckyred-api.service >/dev/null 2>&1; then
              TARGET_SERVICE="luckyred-api"
            fi
            
            echo "Target Service detected: $TARGET_SERVICE"
            
            # 使用变量捕获状态，确保命令总是返回 0，防止脚本意外中断
            BACKEND_STATUS=$(systemctl is-active "$TARGET_SERVICE" 2>/dev/null || echo "inactive")
            
            if [ "$BACKEND_STATUS" = "active" ]; then
              echo "✅ Backend service ($TARGET_SERVICE) is running"
              # 健康检查
              if timeout 10s curl -s -f --max-time 5 http://localhost:8000/health > /dev/null 2>&1; then
                echo "✅ Backend health check: Passed"
              else
                echo "⚠️  Backend health check: Failed (Service is up but API not responding)"
                echo "⬇️ Last 20 lines of logs:"
                sudo journalctl -u "$TARGET_SERVICE" -n 20 --no-pager || true
              fi
            else
              echo "❌ Backend service ($TARGET_SERVICE) failed to start!"
              echo "⬇️ Critical Error Logs (Last 50 lines):"
              # 打印关键日志供调试
              sudo journalctl -u "$TARGET_SERVICE" -n 50 --no-pager || true
              handle_error "Backend service failed to start"
            fi
            
            echo ""
            echo "Checking Bot service..."
            BOT_STATUS=$(systemctl is-active telegram-bot 2>/dev/null || echo "inactive")
            if [ "$BOT_STATUS" = "active" ]; then
              echo "✅ Bot service: Running"
            else
              echo "❌ Bot service: Not running"
              echo "⬇️ Bot Logs:"
              sudo journalctl -u telegram-bot -n 50 --no-pager || true
              handle_error "Bot service failed to start"
            fi
            
            echo ""
            echo "Checking frontend service..."
            FRONTEND_SERVICE=""
            # 使用变量捕获，避免 grep 退出码问题
            SERVICE_LIST=$(systemctl list-units --type=service --no-legend 2>/dev/null || echo "")
            if echo "$SERVICE_LIST" | grep -q "liaotian-frontend" 2>/dev/null; then
              FRONTEND_SERVICE="liaotian-frontend"
            elif echo "$SERVICE_LIST" | grep -q "smart-tg-frontend" 2>/dev/null; then
              FRONTEND_SERVICE="smart-tg-frontend"
            fi
            
            if [ -n "$FRONTEND_SERVICE" ]; then
              FRONTEND_STATUS=$(systemctl is-active "$FRONTEND_SERVICE" 2>/dev/null || echo "inactive")
              if [ "$FRONTEND_STATUS" = "active" ]; then
                echo "✅ Frontend service ($FRONTEND_SERVICE): Running"
                HTTP_CODE=$(timeout 10s curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:3000 2>/dev/null || echo "000")
                if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
                  echo "✅ Frontend HTTP response: Normal (HTTP $HTTP_CODE)"
                else
                  echo "⚠️  Frontend HTTP response: Abnormal (HTTP $HTTP_CODE)"
                  echo "⬇️ Last 20 lines of logs:"
                  sudo journalctl -u "$FRONTEND_SERVICE" -n 20 --no-pager || true
                fi
              else
                echo "❌ Frontend service ($FRONTEND_SERVICE): Not running"
                echo "⬇️ Frontend Logs:"
                sudo journalctl -u "$FRONTEND_SERVICE" -n 50 --no-pager || true
                handle_error "Frontend service failed to start"
              fi
            else
              echo "⚠️  Frontend systemd service not found"
            fi
            
            echo ""
            echo "=========================================="
            echo "Deployment completed - $(date)"
            echo "=========================================="
            echo "✅ Code updated"
            echo "✅ Services restarted"
            echo ""
            echo "Service URLs:"
            echo "  - Frontend: http://${{ secrets.SERVER_HOST }}"
            echo "  - Backend API: http://${{ secrets.SERVER_HOST }}:8000"
            echo "  - API Docs: http://${{ secrets.SERVER_HOST }}:8000/docs"
